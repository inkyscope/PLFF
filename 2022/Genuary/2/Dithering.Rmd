---
title: "2.Dithering"
author: "Sung Inkyung"
date: '2022 1 2'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
### Source[Image Dithering in R](https://www.r-bloggers.com/2019/01/image-dithering-in-r/)
```{r}
library(flametree)
library(dplyr)
library(ggplot2)
library(ragg)
library(nord)

nord(palette = "frost")
```


```{r}
set.seed(123)

# pick some colors 
shades <- c("#8FBCBB", "#88C0D0", "#81A1C1", "#5E81AC")

# data structure defining the trees
dat <- flametree_grow(trees = 30,
                      shift_x = spark_nothing()) 

# draw the plot
plot <- dat %>% 
  flametree_plot(
    background = "white",
    palette = shades,
    #style = plain" (the default), "voronoi", "wisp", "nativeflora", "minimal", or "themegray"
    style = "minimal" 
  ) 

flametree_save(plot, filename = "trees.png", height = 7, width = 7)

```

```{r}
library(imager)

trees <- load.image("trees.png")
trees_gray <- grayscale( rm.alpha(trees) )
plot(trees_gray)

trees_threshold <- trees_gray > 0.5
plot(trees_threshold)

rand_matrix <- matrix(
  data = runif(length(trees_gray)),
  ncol = ncol(trees_gray), 
  nrow = nrow(trees_gray))
rand_cimg <- as.cimg(rand_matrix)
plot(rand_cimg)

trees_rand <- trees_gray > rand_cimg
plot(trees_rand)
```


```{r}
checker_pattern <- rbind(c(1/3, 2/3),
                         c(2/3, 1/3))
plot(as.cimg(checker_pattern))

# rep_mat takes a matrix (mat) and tiles it so that the resulting
# matrix has size nrow_out x ncol_out.
# It's basically a 2d version of rep()
rep_mat <- function(mat, nrow_out, ncol_out) {
  mat[rep(seq_len(nrow(mat)), length.out = nrow_out),
      rep(seq_len(ncol(mat)), length.out = ncol_out)]
}

checker_cimg <- as.cimg(rep_mat(checker_pattern,
                                nrow(trees_gray),
                                ncol(trees_gray)))
plot(checker_cimg)

trees_checker <- trees_gray > checker_cimg
plot(trees_checker)

gradient <- as.cimg(rep(seq(0, 1, 0.01), 101), 
                    x = 101, y = 101)
plot(gradient)
```


```{r}
checker_cimg <- as.cimg(rep_mat(checker_pattern,
                                nrow(gradient),
                                ncol(gradient)))

gradient_checker <- gradient > checker_cimg
plot(gradient_checker)
```

```{r}
# Calculates a non-normalized Bayer pattern matrix of size 2^n
recursive_bayer_pattern <- function(n) {
  if(n <= 0) {
    return(matrix(0))
  }
  m <- recursive_bayer_pattern(n - 1)
  rbind(
    cbind(4 * m + 0, 4 * m + 2),
    cbind(4 * m + 3, 4 * m + 1))
}
# Returns a Bayer pattern of size 2^n normalized so all values
# are between 0.0 and 1.0.
normalized_bayer_pattern <- function(n) {
  pattern <- recursive_bayer_pattern(n)
  (1 + pattern) / ( 1 + length(pattern) )
}
par(mfcol = c(1, 3), mar = c(0, 0, 2, 1), ps = 18)
plot(as.cimg(normalized_bayer_pattern(1)), main = "Bayer 2×2")
plot(as.cimg(normalized_bayer_pattern(2)), main = "Bayer 4×4")
plot(as.cimg(normalized_bayer_pattern(3)), main = "Bayer 8×8")

bayer_cimg <- as.cimg(rep_mat(normalized_bayer_pattern(2),
                              nrow(gradient), ncol(gradient)))
gradient_bayer <- gradient > bayer_cimg
plot(gradient_bayer)
```
```{r black & white}
bayer_matrix <- rep_mat(normalized_bayer_pattern(2),
                        nrow(trees_gray),
                        ncol(trees_gray))

bayer_cimg <- as.cimg(bayer_matrix)
trees_bayer <- trees_gray > bayer_cimg

plot(trees_bayer,
     axes = F)
```


```{r color}
trees_bayer_color <- trees
for(rgb_i in 1:3) {
  color_channel <- trees_bayer_color[ , , 1, 
                                      rgb_i, 
                                      drop = FALSE]
  trees_bayer_color[ , , 1, rgb_i] <- color_channel > bayer_cimg
}

plot_final <- plot(trees_bayer_color,
                   axes = F) 

```

